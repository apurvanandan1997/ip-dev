-- -------------------------------------------------------------
-- 
-- File Name: /home/apurvan/BBU/qpskprj/hdlsrc/nrhdlSymbolModulatorModel/NR_Symbol_Modulator_block.vhd
-- Created: 2020-01-24 17:38:16
-- 
-- Generated by MATLAB 9.6 and HDL Coder 3.14
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: NR_Symbol_Modulator_block
-- Source Path: nrhdlSymbolModulatorModel/NR Symbol Modulator/NR Symbol Modulator
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.NR_Symbol_Modulator_pkg.ALL;

ENTITY NR_Symbol_Modulator_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        data                              :   IN    std_logic;
        valid                             :   IN    std_logic;
        data1_re                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        data1_im                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        valid1                            :   OUT   std_logic
        );
END NR_Symbol_Modulator_block;


ARCHITECTURE rtl OF NR_Symbol_Modulator_block IS

  -- Constants
  CONSTANT nc                             : vector_of_signed16(0 TO 1) := 
    (to_signed(16#2D41#, 16), to_signed(-16#2D41#, 16));  -- sfix16 [2]
  CONSTANT nc_2                           : vector_of_signed16(0 TO 1) := 
    (to_signed(16#2D41#, 16), to_signed(-16#2D41#, 16));  -- sfix16 [2]

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL obj_enbReg                       : std_logic;
  SIGNAL obj_count                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL obj_count_1                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp                              : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_1                            : std_logic;
  SIGNAL tmp_2                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_3                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL tmp_4                            : std_logic;
  SIGNAL out_rsvd                         : std_logic;
  SIGNAL out_rsvd_1                       : std_logic;
  SIGNAL tmp_5                            : std_logic;
  SIGNAL obj_validReg_reg_reg             : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL obj_validReg                     : std_logic;
  SIGNAL obj_dataInReg                    : std_logic;
  SIGNAL obj_shiftReg                     : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL tmp_6                            : std_logic;
  SIGNAL obj_shiftReg_1                   : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL tmp_7                            : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL buffBits                         : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL buffBits_1                       : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL p35_buffBits                     : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL tmp_8                            : std_logic;  -- ufix1
  SIGNAL obj_Iaddr                        : std_logic;  -- ufix1
  SIGNAL tmp_9                            : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL p21tmp_cast                      : signed(31 DOWNTO 0);  -- int32
  SIGNAL obj_Ireg                         : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL tmp_10                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL tmp_11                           : std_logic;  -- ufix1
  SIGNAL obj_Qaddr                        : std_logic;  -- ufix1
  SIGNAL tmp_12                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL p20tmp_cast                      : signed(31 DOWNTO 0);  -- int32
  SIGNAL obj_Qreg                         : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL tmp_13                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL data_re                          : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL data_im                          : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL valid_1                          : std_logic;

BEGIN
  obj_enbReg_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_enbReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_enbReg <= valid;
      END IF;
    END IF;
  END PROCESS obj_enbReg_reg_process;


  -- HDL code generation from MATLAB function: Nondirect_stepImpl_trueregionp39
  obj_count <= to_unsigned(16#0#, 2);

  -- HDL code generation from MATLAB function: Nondirect_stepImpl
  -- 
  -- HDL code generation from MATLAB function: Nondirect_stepImpl_falseregionp39
  tmp <= obj_count_1 + to_unsigned(16#1#, 2);

  
  tmp_1 <= '1' WHEN obj_count_1 = to_unsigned(16#1#, 2) ELSE
      '0';

  -- HDL code generation from MATLAB function: Nondirect_stepImpl_trueregionp23
  
  tmp_2 <= tmp WHEN tmp_1 = '0' ELSE
      obj_count;

  
  tmp_3 <= obj_count_1 WHEN obj_enbReg = '0' ELSE
      tmp_2;

  obj_count_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_count_1 <= to_unsigned(16#0#, 2);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_count_1 <= tmp_3;
      END IF;
    END IF;
  END PROCESS obj_count_reg_process;


  tmp_4 <= hdlcoder_to_stdlogic(obj_count_1 = to_unsigned(16#1#, 2)) AND obj_enbReg;

  -- HDL code generation from MATLAB function: Nondirect_stepImpl_falseregionp27
  out_rsvd <= '0';

  -- HDL code generation from MATLAB function: Nondirect_stepImpl_trueregionp27
  out_rsvd_1 <= '1';

  
  tmp_5 <= out_rsvd WHEN tmp_4 = '0' ELSE
      out_rsvd_1;

  obj_validReg_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_validReg_reg_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_validReg_reg_reg(0) <= tmp_5;
        obj_validReg_reg_reg(1) <= obj_validReg_reg_reg(0);
      END IF;
    END IF;
  END PROCESS obj_validReg_reg_process;

  obj_validReg <= obj_validReg_reg_reg(1);

  obj_dataInReg_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_dataInReg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_dataInReg <= data;
      END IF;
    END IF;
  END PROCESS obj_dataInReg_reg_process;


  tmp_6 <= obj_shiftReg(0);

  -- HDL code generation from MATLAB function: Nondirect_stepImpl_trueregionp32
  p0obj_shiftReg_output : PROCESS (obj_dataInReg, obj_shiftReg, tmp_6)
  BEGIN
    obj_shiftReg_1 <= obj_shiftReg;
    obj_shiftReg_1(1) <= tmp_6;
    obj_shiftReg_1(0) <= obj_dataInReg;
  END PROCESS p0obj_shiftReg_output;


  
  tmp_7 <= obj_shiftReg WHEN obj_enbReg = '0' ELSE
      obj_shiftReg_1;

  obj_shiftReg_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_shiftReg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_shiftReg <= tmp_7;
      END IF;
    END IF;
  END PROCESS obj_shiftReg_reg_process;


  buffBits <= (OTHERS => '0');


  buffBits_1_gen: FOR t_0 IN 0 TO 1 GENERATE
    p35_buffBits(t_0) <= obj_shiftReg(1 - t_0);
    buffBits_1(t_0) <= p35_buffBits(t_0);
  END GENERATE buffBits_1_gen;


  tmp_8 <= buffBits_1(0);

  obj_Iaddr_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_Iaddr <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_Iaddr <= tmp_8;
      END IF;
    END IF;
  END PROCESS obj_Iaddr_reg_process;


  p21tmp_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & obj_Iaddr;
  tmp_9 <= nc(to_integer(p21tmp_cast));

  
  tmp_10 <= obj_Ireg WHEN obj_validReg = '0' ELSE
      tmp_9;

  obj_Ireg_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_Ireg <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_Ireg <= tmp_10;
      END IF;
    END IF;
  END PROCESS obj_Ireg_reg_process;


  tmp_11 <= buffBits_1(1);

  obj_Qaddr_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_Qaddr <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_Qaddr <= tmp_11;
      END IF;
    END IF;
  END PROCESS obj_Qaddr_reg_process;


  p20tmp_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & obj_Qaddr;
  tmp_12 <= nc_2(to_integer(p20tmp_cast));

  
  tmp_13 <= obj_Qreg WHEN obj_validReg = '0' ELSE
      tmp_12;

  obj_Qreg_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      obj_Qreg <= to_signed(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        obj_Qreg <= tmp_13;
      END IF;
    END IF;
  END PROCESS obj_Qreg_reg_process;


  data_re <= obj_Ireg;
  data_im <= obj_Qreg;

  data1_re <= std_logic_vector(data_re);

  data1_im <= std_logic_vector(data_im);

  obj_validRegReg_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      valid_1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        valid_1 <= obj_validReg;
      END IF;
    END IF;
  END PROCESS obj_validRegReg_reg_process;


  valid1 <= valid_1;

END rtl;

